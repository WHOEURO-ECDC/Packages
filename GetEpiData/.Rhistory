id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
adm_0 <- "EURO_COVID19_ADM0_Cases"
country_pop <- get_data(server, adm_0) %>%
select(ADM0_NAME,WHO_CODE,Population=CENTER_LAT) %>%
mutate(ADM0_NAME=str_to_title(ADM0_NAME))
country_pop <- WHOCountryNames(country_pop,ADM0_NAME)
return(country_pop)
}
GetPopulation()
set.wd('C:/Users/romanc/Documents/GitHub/Packages/GetPopulation')
setwd('C:/Users/romanc/Documents/GitHub/Packages/GetPopulation')
document()
library(devtools)
document()
rm(list = c("GetPopulation"))
document()
setwd(..)
setwd()
setwd('..')
getwd
getwd()
install(GetPopulation)
install('GetPopulation')
GetPopulation()
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Current_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Current_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
get_data()
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
get_data()
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
get_data()
content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
id_field
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
data
server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
service_daily <- "EURO_COVID19_Running_v3"
MainDataset<-get_data(server, service_daily)
#' GetEpiData function
#' This function read the running epi data online
#' @export
#'
GetEpiData <- function(){
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
adm_0 <- "EURO_COVID19_Running_v3"
MainDataset <- get_data(server, adm_0)
return(MainDataset)}
GetEpiData()
#' GetEpiData function
#' This function read the running epi data online
#' @export
#'
GetEpiData <- function(){
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
#server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
#adm_0 <- "EURO_COVID19_Running_v3"
data
return(data)
}
GetEpiData()
#' GetEpiData function
#' This function read the running epi data online
#' @export
#'
GetEpiData <- function(){
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste('https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services',
'EURO_COVID19_Running_v3',"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
#server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
#adm_0 <- "EURO_COVID19_Running_v3"
#data
return(data)
}
GetEpiData()
getwd()
setwd('C:/Users/romanc/Documents/GitHub/Packages/GetEpiData')
getwd()
document()
rm(list = c("GetEpiData"))
document()
install_github('EUROHIM/Packages/GetEpiData')
install_github('WHOEURO-ECDC/Packages/GetEpiData')
