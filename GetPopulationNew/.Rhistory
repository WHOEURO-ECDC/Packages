returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
# server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
# name <- "EURO_COVID19_Running_v3"
#
# epi_data <- get_data
data
#country_pop <- WHOCountryNames(country_pop,ADM0_NAME)
return(epi_data)
}
#' GetEpiData function
#' This function read the running epi data online
#' @export
#'
GetEpiData<-function(){
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
# server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
# name <- "EURO_COVID19_Running_v3"
#
# epi_data <- get_data
#data
#country_pop <- WHOCountryNames(country_pop,ADM0_NAME)
return(data)
}
GetEpiData()
#' GetEpiData function
#' This function read the running epi data online
#' @export
#'
GetEpiData<-function(){
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
data<-get_data()
# server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
# name <- "EURO_COVID19_Running_v3"
#
# epi_data <- get_data
#data
#country_pop <- WHOCountryNames(country_pop,ADM0_NAME)
return(data)
}
GetEpiData()
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
records <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8")
records <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = TRUE,
f = "json")),
as = "text", encoding = "UTF-8")
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
View(res)
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
#' GetEpiData function
#' This function read the running epi data online
#' @export
#'
GetEpiData<-function(){
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer',
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
data<-get_data()
# server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
# name <- "EURO_COVID19_Running_v3"
#
# epi_data <- get_data
#data
#country_pop <- WHOCountryNames(country_pop,ADM0_NAME)
return(data)
}
GetEpiData()
EuroDataset_Today<-read.csv('C:/Users/romanc/Desktop/qry_COVID_running_cases_country_date.csv')
EuroDataset<-read.csv('C:/Users/romanc/Desktop/qry_COVID_running_cases_country_date.csv') %>%
EuroDataset<-read.csv('C:/Users/romanc/Desktop/qry_COVID_running_cases_country_date.csv') %>%
mutate(ADM0NAME=str_to_title(ADM0NAME))
EuroDataset<-read.csv('C:/Users/romanc/Desktop/qry_COVID_running_cases_country_date.csv') %>%
mutate(ADM0NAME=str_to_title(ADM0NAME))
CurrentDate<-max(EuroDataset$DateReport)
CurrentDate
EuroDataset_Today<-EuroDataset %>% filter(DateReport==CurrentDate)
EuroDataset<-read.csv('C:/Users/romanc/Desktop/qry_COVID_running_cases_country_date.csv') %>%
mutate(ADM0NAME=str_to_title(ADM0NAME)) %>%
rename(DateReport=DateReport1)
EuroDataset_Today<-EuroDataset %>% filter(DateReport==CurrentDate)
server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
adm_0 <- "EURO_COVID19_ADM0_Cases"
service_name<-adm_0
paste(server,service_name,"FeatureServer",layer_id,"query?",sep="/")
layer_id=0
get_data<-function(server,service_name,layer_id=0,w="1=1",rg="false",of="*"){
#gets data from an Esri feature service.
#
# args:
#   server (string): name of the arcgis server
#   service_name (string): name of the feature service
#   layer id (int): id of the layer, default = 0
#   w (string): where condition, default = "1=1",
#   rg(string): defines whether geometry is exported. Must be either 'false' or 'true'. Note values must be a string not a boolean
#   of (string): list of output fields. Must be a string not a list or vector. Default is set to export all columns ("*)
#   f (string): output format
#
# returns:
# data (tibble): feature service converted to a tibble
out <- tryCatch(
{
# Get the maximum id. This is need to define the number of calls required to fetch data
res <- content(GET(url = paste(server,service_name,"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
id_field <- res$objectIdFieldName # if fails use this res[[1]]
n_records <- list()
n_records$max_id <- unlist(res[[2]]) %>% max()
n_records$count <- length(res[[2]])
# Do until all records are exported
# Retrieve recrords from the feature service and merge into a single data frame
id <- 0
data <- tibble()
while (id<n_records$max_id) {
records <- content(GET(url = paste(server,service_name,"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = paste(w,"and",id_field,">=",id) ,
returnGeometry = rg,
outFields = of,
returnIdsOnly = FALSE,
f = "json")),
as = "text", encoding = "UTF-8") %>%
fromJSON(., flatten = TRUE)  %>% .$features %>% as_tibble() %>%
rename_all(list(~ sub(".*?[[:punct:]]", "",.)))
id_new <- records %>% summarise(max(!!as.name(id_field))) %>% pull
if(nrow(records)==0 | id_new == id ) {
#if no records are returned, break loop
break
} else{
data <- rbind(data,records)
id <- id_new +1
}
}
#convert esri data to dttm
data <- data %>%  mutate_if(~ (is.double(.) && min(., na.rm = TRUE) > 1e12 && min(., na.rm = TRUE) %% 1000 ==0) , list(~as.POSIXct(./1000,origin="1970-01-01",tz="GMT")))
# retrun data
return(data)
},
error = function(cond) {
message(paste0("Request failed. Please review the paramaters."))
#message(request$status_code)
message(cond)
})
}
w="1=1"
rg="false"
of="*"
paste(server,service_name,"FeatureServer",layer_id,"query?",sep="/")
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer/0/query?',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
library(httr)
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer/0/query?',
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer/0/query?',
query = list(
where = "1=1",
returnGeometry = "false",
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
list(
where = "1=1",
returnGeometry = "false",
returnIdsOnly = TRUE,
f = "json")
res
id_field <- res$objectIdFieldName # if fails use this res[[1]]
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer/0/query?',
query = list(
where = "1=1",
returnGeometry = "false",
returnIdsOnly = TRUE,
f = "json")))
res
id_field <- res[[1]]#res$objectIdFieldName # if fails use this res[[1]]
id_field
res <- content(GET(url = 'https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/EURO_COVID19_Running_v3/FeatureServer/0/query?',
query = list(
where = "1=1",
returnGeometry = "false",
returnIdsOnly = TRUE,
f = "json")))
res
server <- "https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services"
adm_0 <- "EURO_COVID19_ADM0_Cases"
service_name<-adm_0
res <- content(GET(url = paste(server,service_name,"FeatureServer",layer_id,"query?",sep="/"),
query = list(
where = w,
returnGeometry = rg,
returnIdsOnly = TRUE,
f = "json"),
as = "text", encoding = "UTF-8"))
res
EuroDataset<-read.csv('C:/Users/romanc/Desktop/qry_COVID_running_cases_country_date.csv') %>%
mutate(ADM0NAME=str_to_title(ADM0NAME)) %>%
rename(DateReport=DateReport1)
library(dplyr)
EuroDataset<-read.csv('C:/Users/romanc/Desktop/qry_COVID_running_cases_country_date.csv') %>%
mutate(ADM0NAME=str_to_title(ADM0NAME)) %>%
rename(DateReport=DateReport1)
library(stringr)
getwd('C:/Users/romanc/Documents/GitHub/Packages')
setwd('C:/Users/romanc/Documents/GitHub/Packages')
install('GetPopulationNew')
library(devtools)
install('GetPopulationNew')
GetPopulationNew()
library('GetPopulationNew')
GetPopulationNew()
library(dplyr)
detach("package:dplyr", unload = TRUE)
library(dplyr)
GetPopulationNew()
library(stringr)
GetPopulationNew()
setwd('./GetPopulationNew')
library(roxygen2)
use_package('dplyr',type='Depends')
use_package('stringr',type='Depends')
document()
